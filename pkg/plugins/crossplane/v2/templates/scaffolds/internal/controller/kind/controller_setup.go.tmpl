{{ .Boilerplate }}

// Code generated by xp-provider-gen. DO NOT EDIT.
// This file contains auto-generated Crossplane controller setup configuration.
// To add custom setup logic, use the SetupWithOptions function in controller.go

package {{ .Resource.Kind | lower }}

import (
	"github.com/crossplane/crossplane-runtime/v2/pkg/controller"
	"github.com/crossplane/crossplane-runtime/v2/pkg/event"
	"github.com/crossplane/crossplane-runtime/v2/pkg/feature"
	"github.com/crossplane/crossplane-runtime/v2/pkg/ratelimiter"
	"github.com/crossplane/crossplane-runtime/v2/pkg/reconciler/managed"
	"github.com/crossplane/crossplane-runtime/v2/pkg/resource"
	"github.com/crossplane/crossplane-runtime/v2/pkg/statemetrics"
	"github.com/pkg/errors"
	ctrl "sigs.k8s.io/controller-runtime"

	"{{ .Repo }}/apis/{{ .Resource.Group }}/{{ .Resource.Version }}"
)

// Setup adds a controller that reconciles {{ .Resource.Kind }} managed resources.
// This function is auto-generated and provides the standard Crossplane controller setup.
// For custom setup logic, implement SetupWithOptions in controller.go
func Setup(mgr ctrl.Manager, o controller.Options) error {
	return SetupWithOptions(mgr, o, SetupOptions{})
}


// SetupWithOptions sets up the controller with customizable options.
// This function provides a hook for custom setup logic while maintaining
// the auto-generated Crossplane feature configuration.
// The SetupOptions struct is defined in controller.go for user customization.
func SetupWithOptions(mgr ctrl.Manager, o controller.Options, setupOpts SetupOptions) error {
	name := managed.ControllerName({{ .Resource.Version }}.{{ .Resource.Kind }}GroupKind)

	// Build the connector - this calls the user-customizable function
	connector, err := NewConnector(mgr, setupOpts)
	if err != nil {
		return errors.Wrap(err, "cannot create connector")
	}

	// Auto-generated Crossplane reconciler options
	opts := buildReconcilerOptions(mgr, o, name, connector)

	// Auto-generated state metrics setup
	if err := setupStateMetrics(mgr, o); err != nil {
		return err
	}

	// Create and configure the controller
	r := managed.NewReconciler(mgr, resource.ManagedKind({{ .Resource.Version }}.{{ .Resource.Kind }}GroupVersionKind), opts...)

	return ctrl.NewControllerManagedBy(mgr).
		Named(name).
		WithOptions(o.ForControllerRuntime()).
		WithEventFilter(resource.DesiredStateChanged()).
		For(&{{ .Resource.Version }}.{{ .Resource.Kind }}{}).
		Complete(ratelimiter.NewReconciler(name, r, o.GlobalRateLimiter))
}

// buildReconcilerOptions constructs the managed reconciler options with all Crossplane features.
// This function is auto-generated and will be updated when new Crossplane features are added.
func buildReconcilerOptions(mgr ctrl.Manager, o controller.Options, name string, connector managed.ExternalConnector) []managed.ReconcilerOption {
	opts := []managed.ReconcilerOption{
		managed.WithExternalConnector(connector),
		managed.WithLogger(o.Logger.WithValues("controller", name)),
		managed.WithPollInterval(o.PollInterval),
		managed.WithRecorder(event.NewAPIRecorder(mgr.GetEventRecorderFor(name))),
	}

	// Auto-generated feature flags - this section will be updated automatically
	// when new Crossplane features are introduced
	if o.Features.Enabled(feature.EnableBetaManagementPolicies) {
		opts = append(opts, managed.WithManagementPolicies())
	}

	if o.Features.Enabled(feature.EnableAlphaChangeLogs) {
		opts = append(opts, managed.WithChangeLogger(o.ChangeLogOptions.ChangeLogger))
	}

	// Auto-generated metric options
	if o.MetricOptions != nil {
		opts = append(opts, managed.WithMetricRecorder(o.MetricOptions.MRMetrics))
	}

	return opts
}

// setupStateMetrics configures state metrics for the managed resource.
// This function is auto-generated and handles the standard state metrics setup.
func setupStateMetrics(mgr ctrl.Manager, o controller.Options) error {
	if o.MetricOptions != nil && o.MetricOptions.MRStateMetrics != nil {
		stateMetricsRecorder := statemetrics.NewMRStateRecorder(
			mgr.GetClient(),
			o.Logger,
			o.MetricOptions.MRStateMetrics,
			&{{ .Resource.Version }}.{{ .Resource.Kind }}List{},
			o.MetricOptions.PollStateMetricInterval,
		)
		if err := mgr.Add(stateMetricsRecorder); err != nil {
			return errors.Wrap(err, "cannot register MR state metrics recorder for kind {{ .Resource.Version }}.{{ .Resource.Kind }}List")
		}
	}
	return nil
}